const drawPlotly = (points) =>{
  const trace1 = {
    x: points.map(v=>v[0]),
    y: points.map(v=>v[1]), 
    marker: {size: 8}, 
    mode: 'lines+markers', 
    name: 'Foot-y [m]', 
    type: 'scatter', 
  }
  
  const data = [trace1];
  var layout = {
    autosize: true, 
    height: 500, 
    title: 'Foot and Head Trajectories', 
    width: 800, 
    xaxis: {
      autorange: true, 
      title: 'x-Position [m]', 
      type: 'linear'
    }, 
    yaxis: {
      autorange: true, 
      title: 'y-Position [m]', 
      type: 'linear'
    }
  };
  Plotly.newPlot('draw',data, layout,{
      editable: true,
      scrollZoom: true,
      showLink: false,
      displaylogo: false,
      modeBarButtonsToRemove: ['sendDataToCloud']
    }
  );

}

const width = document.getElementById("drawArea")
  .getBoundingClientRect().width || 400 ;
const height =document.getElementById("drawArea")
  .getBoundingClientRect().height || 400;
  
const draw = SVG('draw').panZoom({zoomFactor:1.1});

draw.width(width);
draw.height(height);
draw.attr('preserveAspectRatio', 'xMinYMin slice');
draw.style( {
  border: '1px solid #F5F5F5',
  margin:0,
  padding:0,
  background:'linear-gradient(to bottom, white, RoyalBlue )'
});

draw.viewbox(0, 0, width, height).flip('y');

draw.background = draw.group();
draw.background.line(-1000, 0, 1000, 0).fill("none").stroke({color:"black",opacity: 1.0,width:1})
  .attr("vector-effect", "non-scaling-stroke")
  .attr("stroke-dasharray","5 5");
draw.background.line(0, -1000, 0, 1000).fill("none").stroke({color:"black",opacity: 1.0,width:1})
  .attr("vector-effect", "non-scaling-stroke")
  .attr("stroke-dasharray","5 5");

draw.screen=draw.group();
draw.screen.stroke({color:"blue",opacity: 1.0,width:1});
draw.screen.sheet = [];
draw.screen.sheet.push(draw.screen.group());

const drawPolyline = (list,color="blue") =>{
  draw.screen.sheet[0].polyline(list)  
  .attr("vector-effect", "non-scaling-stroke")
  .fill("none")
  .stroke({color:color})
}
const drawPoint = (list,color="blue") =>{
  list.forEach(v=>{
    draw.screen.sheet[0].circle(0.5).center(v[0], v[1]) 
    .attr("vector-effect", "non-scaling-stroke")
    .fill("black")
    .stroke({color:color})   
  })

}

const drawCircle = (cx,cy, r,color="blue") =>{
  draw.screen.sheet[0].circle(r*2).center(cx, cy) 
  .attr("vector-effect", "non-scaling-stroke")
  .fill("none")
  .stroke({color:color})
}

const blade1 = ()=>{
  const sF = x => -0.8*(x/5-10)**2+60
  const pF = x => -0.6*(x/7-11)**2+50
  
  const sPoints = [...Array(65)].map((v,i)=>[i+1,sF(i+1)])
  const pPoints = [...Array(65)].map((v,i)=>[i+1,pF(i+1)])
  const offset = 50
  const sPointsCopy = sPoints.map(v=>[v[0], v[1]+offset])
  const pPointsCopy = pPoints.map(v=>[v[0], v[1]+offset])
  
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  drawPolyline(pPointsCopy)
  drawPolyline(sPointsCopy)
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPointsCopy, false)
  return {sSpline: sSpline, pSpline:pSpline}
}

const blade2 = ()=>{
  const sF = x => -0.8*(x/5-10)**2+60
  const pF = x => -0.6*(x/7-11)**2+50
  
  const sPoints = [...Array(65)].map((v,i)=>[i+1,sF(i+1)])
  const pPoints = [...Array(65)].map((v,i)=>[i+1,pF(i+1)])
 
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPoints, false)
  return {sSpline: sSpline, pSpline:pSpline}
}

const blade3 = ()=>{
  const sF = x => -0.8*(x/4.8-10)**2+62
  const pF = x => -0.51*(x/7-13)**2+51
  
  const sPoints = [...Array(65)].map((v,i)=>[i+1,sF(i+1)])
  const pPoints = [...Array(65)].map((v,i)=>[i+1,pF(i+1)])
  const offset = 70
  const sPointsCopy = sPoints.map(v=>[v[0], v[1]+offset])
  const pPointsCopy = pPoints.map(v=>[v[0], v[1]+offset])
  
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  drawPolyline(pPointsCopy)
  drawPolyline(sPointsCopy)
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPointsCopy, false)
  return {sSpline: sSpline, pSpline:pSpline}
}
const quarterCircle=()=>{
  const pF = t => [50*Math.sin(t/180*Math.PI),100-50*Math.cos(t/180*Math.PI)]
  const sF = t => [100*Math.sin(t/180*Math.PI),100-100*Math.cos(t/180*Math.PI)]
  const sPoints = [...Array(19)].map((v,i)=>sF(i*5))
  const pPoints = [...Array(19)].map((v,i)=>pF(i*5))
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPoints, false)
  return {sSpline: sSpline, pSpline:pSpline}
}

const halfCircle =()=>{
  const pF = t => [50*Math.sin((t-90)/180*Math.PI),100-50*Math.cos((t-90)/180*Math.PI)]
  const sF = t => [100*Math.sin((t-90)/180*Math.PI),-100+100*Math.cos((t-90)/180*Math.PI)]
  const sPoints = [...Array(39)].map((v,i)=>sF(i*5))
  const pPoints = [...Array(39)].map((v,i)=>pF(i*5))
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPoints, false)
  return {sSpline: sSpline, pSpline:pSpline} 
}

const parallelLine = ()=>{
  const pF = t => [t,100]
  const sF = t => [t, 200]
  const sPoints = [...Array(39)].map((v,i)=>sF(i*5))
  const pPoints = [...Array(39)].map((v,i)=>pF(i*5))
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPoints, false)
  return {sSpline: sSpline, pSpline:pSpline} 
} 

const taperLine = ()=>{
  const pF = t => [t,100+t*Math.tan(10/180*Math.PI)]
  const sF = t => [t, 200+t*Math.tan(30/180*Math.PI)]
  const sPoints = [...Array(39)].map((v,i)=>sF(i*5))
  const pPoints = [...Array(39)].map((v,i)=>pF(i*5))
  drawPolyline(pPoints)
  drawPolyline(sPoints)
  
  const sSpline = sci.interpolate.normalizedCubicspline(sPoints, false)
  const pSpline = sci.interpolate.normalizedCubicspline(pPoints, false)
  return {sSpline: sSpline, pSpline:pSpline} 
} 
//const {sSpline,pSpline} = blade1() 
//const {sSpline,pSpline} = blade2() 
const {sSpline,pSpline} = blade3() 
//const {sSpline,pSpline} = quarterCircle() 
//const {sSpline,pSpline} = halfCircle() 
//const {sSpline,pSpline} = parallelLine() 
//const {sSpline,pSpline} = taperLine() 

const sSplinePoints = [...Array(101)].map((v,i)=>[sSpline.X(i/100),sSpline.Y(i/100)])
const pSplinePoints = [...Array(101)].map((v,i)=>[pSpline.X(i/100),pSpline.Y(i/100)])

drawPolyline(pSplinePoints,"red")
drawPolyline(sSplinePoints,"red")



const main2 = ()=>{
  const N = 10
  const maxIteration = 30
  const tolerance = 1E-5
  const divisions = 100
  const P = [10,30]
  const start = performance.now()
  const res = minDistanceFromPointToCurve(P, sSpline, N, maxIteration, tolerance)
  const end = performance.now()
  const elapsedTime = (end-start)
  console.log("elapsed time", elapsedTime,"ms")
  console.log(res)
  const S = res.S 
  const distance = res.distance
  
  const points = [P, S]
  drawPoint(points)
  drawPolyline(points)
  drawCircle(P[0],P[1],distance,"orange")
}
main2()

