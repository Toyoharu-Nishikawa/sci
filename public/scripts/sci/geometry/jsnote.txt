console.clear()

const f1 = x => -1/20* (x-14)**2 + 5 
const f2 = x => -1/10* (x-6)**2 + 14 
const transpose = A=>A[0].map((k,i)=>A.map((v)=>v[i]))

const newtonMethod1D = (x0,f,df, maxIteration,tolerance)=>{
  let x=x0
  let y = f(x)
  let dfdx = df(x0) 
  let count=0
  while(count<maxIteration){
    const dx = -y/dfdx
    x +=dx
    y = f(x)
    if(Math.abs(y)<tolerance){
      break
    }
    dfdx = df(x) 
    count++
  }
  const result = {
    converged: count < maxIteration ? true: false,
    error : Math.abs(y),
    count :count,
    value: x,
  }
  return result 
}

const divideMinMax = (min, max, N) => {
  const list = [...Array(N)].map((v,i)=>min+(max-min)*i/(N-1))
  return list
}

const cartesianToCylindrical = xyz => {
  const x = xyz[0]
  const y = xyz[1]
  const z = xyz[2]
  
  const r = Math.sqrt(y**2+z**2)
  const rt = r*Math.atan2(-y, z)
  const xrtr = [x, rt, r]
  return xrtr
}

const cylindricalToCartesian = xrtr => {
  const x = xrtr[0]
  const rt = xrtr[1]
  const r = xrtr[2]
  
  const theta = rt/r 
  const y = -r*Math.sin(theta)
  const z = r*Math.cos(theta) 
  const xyz = [x,y,z] 
  return xyz
}

const RA = [
  [300, 0],
  [325, 0],
  [350, 0],
  [375, 0],
  [400, 0],
]

const calcCirclePoint = (c, r, theta) => {
  const dx = r*Math.cos(theta)
  const dy = r*Math.sin(theta)
  const x = c[0] + dx
  const y = c[1] + dy
  const p = [x, y]
  return p
}

const rotSlide = (vec, ra) => {
  const theta = ra[1]/180*Math.PI
  const z = ra[0]
  const x = vec[0]* Math.cos(theta) -  vec[1]* Math.sin(theta)
  const y = vec[0]* Math.sin(theta) +  vec[1]* Math.cos(theta)
  const p = [x, y, z]
  return p
}


const getThreePolylineObj = (points,color="white",closed=true) =>{ 
  const ps = points.map(v=>new THREE.Vector3(v[0],v[1],v[2]))
  if(closed){
    ps.push(ps[0])
  }
 
  
  const points3D = new THREE.Geometry();

  points3D.vertices = ps
  const line2 = new THREE.Line(points3D, new THREE.LineBasicMaterial({color: color}));
  //scene.add(line2);
  return line2 
}

const offsetPath = (path, offset) => {
  const P1 = path[0] 
  const P2 = path[1] 
  const dP = [P2[0]-P1[0], P2[1]-P1[1]]
  const l = Math.sqrt(dP[0]**2+dP[1]**2)
  const dp = [dP[0]/l, dP[1]/l] 
  const dt = [-dp[1], dp[0]]
  
  const Q1 = [P1[0]+offset*dt[0], P1[1]+offset*dt[1]]
  const Q2 = [P2[0]+offset*dt[0], P2[1]+offset*dt[1]]
  const newPath = [Q1, Q2]
  return newPath
}

const absVec = a => {
  const c2 = a.reduce((p,c)=>p+c**2,0)  
  const c = Math.sqrt(c2)
  return c
}

const subVec = (a,b) => {
  const u = a.map((v,i)=>v-b[i]) 
  return u
}

const addVec = (a,b) => {
  const u = a.map((v,i)=>v+b[i]) 
  return u
}

const mulVec = (t, a) => {
  const u = a.map((v,i)=>t*v) 
  return u
}

const innerProduct = (a, b) => {
  const c = a.reduce((p,c,i)=>p+c*b[i],0) 
  return c 
}

const getAngle = (a,b) => {
  const c = innerProduct(a,b)
  const absA = absVec(a) 
  const absB = absVec(b) 
  const cos = c/(absA*absB)
  const theta = Math.acos(cos)
  return theta
}

const normVec = a => {
  const l2 = a.reduce((p,c)=>p+c**2,0)
  const l = Math.sqrt(l2)
  const n = a.map(v=>v/l)
  return n
}

const vectorProduct = (a, b) => {
  const c = [
    a[1]*b[2]-a[2]*b[1],
    a[2]*b[0]-a[0]*b[2],
    a[0]*b[1]-a[1]*b[0],
  ]
  return c
}

const reverseVec = a => {
  const u = a.map(v=>-v) 
  return u
}

const getCrossPointsOfSplineAndCone = (ribCSplineRX,  path, rIni=0,maxIteration=30, tolerance=1E-5) => {

  const pathT = path.map(v=> [v[1], v[0]])
  
  const flag = Math.abs(pathT[1][0] - pathT[0][0]) >1E-12
  if(flag){
    const tan = (pathT[1][1] - pathT[0][1]) /(pathT[1][0] - pathT[0][0])
    const lineF = r =>  tan*(r-pathT[0][0]) + pathT[0][1]
    const getR = (func) => {
      const f = r => func.f(r) - lineF(r) 
      const df = r => func.df(r) - tan 
      const x0 =rIni
      const ans = newtonMethod1D(x0, f, df, maxIteration, tolerance)
      const R = ans.value
      return R
    }
    
    const R = getR(ribCSplineRX)
    return R
  }
  else{
    R = pathT[0][0]  
    return R
  }
}

const getPerpendicularHootFromPoint = (ribSplineZX,ribSplineZY,P, iniZ, maxIteration,tolerance) => {
  const f = z => {
    const x = ribSplineZX.f(z)
    const y = ribSplineZY.f(z)
    const dx = ribSplineZX.df(z)
    const dy = ribSplineZY.df(z)
    const Q = [x,y,z]
    const PQ = subVec(P, Q)
    const dQ = [dx, dy, 1]
    const c = innerProduct(PQ,dQ)
    return c
  } 
  const df = z => {
    const x = ribSplineZX.f(z)
    const y = ribSplineZY.f(z)
    const dx = ribSplineZX.df(z)
    const dy = ribSplineZY.df(z)
    const d2x = ribSplineZX.d2f(z)
    const d2y = ribSplineZY.d2f(z)
    const Q = [x,y,z]
    const PQ = subVec(P, Q)
    const dQ = [dx, dy, 1]
    const d2Q = [d2x, d2y, 0]
    const c1 = innerProduct(dQ,dQ)
    const c2 = innerProduct(Q,d2Q)
    const c = c1+c2
    return c
  } 
  
  
  const res = newtonMethod1D(iniZ, f, df, maxIteration, tolerance)
  const z = res.value 
  const x = ribSplineZX.f(z)
  const y = ribSplineZY.f(z)
  const Q = [x, y, z]
  const d = absVec(subVec(P,Q))
  console.log("z",iniZ, z)
  
  return Q
}

const getNormalVecByThreePoints = (P, Q, R) => {
  const dpq = normVec(subVec(Q,P)) 
  const dpr = normVec(subVec(R,P)) 
  const dn = vectorProduct(dpq, dpr) 
  return dn
}

const getNormalVecOfSurface = coordinates => {
  
  const dn = coordinates.map((v,i,arr)=>{
    if(i<arr.length-1) { 
      const res = v.map((u,j,brr)=>
        j<brr.length-1 ? getNormalVecByThreePoints(u, brr[j+1], arr[i+1][j]):getNormalVecByThreePoints(u, brr[0], arr[i+1][j])
      )
      return res
    }
    else{ 
      const res = v.map((u,j,brr)=>
        j<brr.length-1 ? reverseVec(getNormalVecByThreePoints(u, brr[j+1], arr[i-1][j])):reverseVec(getNormalVecByThreePoints(u, brr[0],  arr[i-1][j]))
      )
      return res
    }
  })
  return dn
}

const getOffsetSurface = (coordinate, fillet) => {
  const dn = getNormalVecOfSurface(coordinate) 
  const offsetSurface = coordinate.map((v,i)=>v.map((u,j)=>addVec(u, mulVec(fillet,dn[i][j])) )) 
  return offsetSurface
}

const getPerpendicularFooForCone = (path, P) => {
  const x0 = P[0] 
  const y0 = P[1] 
  const z0 = P[2] 
  const r0 = Math.sqrt(y0**2+z0**2)
  const theta0 = Math.atan2(-y0,z0)
  
  const A = path[0]
  const B = path[1]
  const C = [x0, r0]
  
  const BA = subVec(B,A)
  const CA = subVec(C,A)
  const t = (BA[0]*CA[0]+BA[1]*CA[1])/(BA[0]**2+BA[1]**2)
  const Q = [A[0]+t*BA[0],A[1]+t*BA[1]]
  const x1 = Q[0]
  const r1 = Q[1]
  const y1 = -r1*Math.sin(theta0)
  const z1 = r1*Math.cos(theta0)
  const H = [x1, y1, z1]
  //
  //
  return H
}

const makeQuaternion = (vec, theta) => {
  const vec2 = normVec(vec)
  const sin = Math.sin(theta/2)
  const cos = Math.cos(theta/2)
  const q0 = vec2[0]*sin
  const q1 = vec2[1]*sin
  const q2 = vec2[2]*sin
  const q3 = cos
  const Q = [q0, q1, q2, q3]
  return Q
}

const invQuaternion = q => {
  const invQ = [-q[0], -q[1],-q[2],q[3]]
  return invQ
}

const mulQQ = (q, p) => {
  const Q = [
    q[3]*p[0] - q[2]*p[1] + q[1]*p[2] + q[0]*p[3],
    q[2]*p[0] + q[3]*p[1] - q[0]*p[2] + q[1]*p[3],
   -q[1]*p[0] + q[0]*p[1] + q[3]*p[2] + q[2]*p[3],
   -q[0]*p[0] - q[1]*p[1] - q[2]*p[2] + q[3]*p[3],
  ]  
  return Q
}

const mulQQlist = (list) => {
  const e = [0,0,0,1]
  const res = list.reduce((p,c)=>mulQQ(p,c),e)
  return res
}

const getFilletPolyline = (center, contact, foot, fillet, N=9) => {
  const CC = subVec(contact, center)
  const cc = normVec(CC)
  const CC2 = mulVec(fillet, cc)
  const contact2 = addVec(center, CC2)
  const FC = subVec(foot, center)
  const fc = normVec(FC)
  const n = vectorProduct(cc, fc)
  
  const phi = getAngle(cc, fc) 
  const theta = [...Array(N)].map((v,i)=>phi*i/(N-1))
  
  const q = theta.map(v=>makeQuaternion(n, v))
  const p = [...CC2,0]
  const q2 = q.map(v=>mulQQlist([v,p,invQuaternion(v)]))
  
  const vec = q2.map(v=>[v[0],v[1],v[2]]) 
  
  const polyline = vec.map(v=>addVec(center,v)).reverse()
  
  return polyline 
  
}

const makeSections = (f1, f2, RA, config) =>{
  const N = config.N//31
  const M = config.M//16 
  const L = config.L//51 
  
  const X = [...Array(N)].map((v,i)=>-16+i) 
  const Yp = X.map(v=>f1(v))
  const Ys = X.map(v=>f2(v))
  
  const Pp = X.map((v,i)=>[v, Yp[i]])
  const Ps = X.map((v,i)=>[v, Ys[i]])
  
  
  const leEdgePoints = [Pp[N-1], Ps[N-1]]
  const teEdgePoints = [Pp[0], Ps[0]]
  
  const pSpline = sci.interpolate.normalizedCubicspline(Pp)
  const sSpline = sci.interpolate.normalizedCubicspline(Ps)
  
  const teCircle = sci.geometry.getContactCircleOfTwoSplinesAndOneLine(pSpline, sSpline, teEdgePoints, 0.1, 0.1)
  console.log(teCircle)
  
  
  const leCircle = sci.geometry.getContactCircleOfTwoSplinesAndOneLine(pSpline, sSpline, leEdgePoints, 0.95, 0.95)
  console.log(leCircle)
  
  const tePt = [...Array(M)].map((v,i)=>teCircle.theta2+(teCircle.theta1+2*Math.PI-teCircle.theta2)/M*i)
  const lePt = [...Array(M)].map((v,i)=>leCircle.theta1+(leCircle.theta2-leCircle.theta1)/M*i)
  
  console.log(tePt,lePt)
 
  const tePoints = tePt.map(v=>calcCirclePoint(teCircle.center,teCircle.radius, v))
  const lePoints = lePt.map(v=>calcCirclePoint(leCircle.center,leCircle.radius, v))
  
  
  const pPt = [...Array(L)].map((v,i)=>teCircle.t1+(leCircle.t1-teCircle.t1)/L*i)
  const sPt = [...Array(L)].map((v,i)=>leCircle.t2-(leCircle.t2-teCircle.t2)/L*i)
  
  const pPoints = pPt.map(v=>[pSpline.X(v), pSpline.Y(v)])
  const sPoints = sPt.map(v=>[sSpline.X(v), sSpline.Y(v)])
  
  
  const curve = [].concat(tePoints, pPoints, lePoints, sPoints)
  console.log(curve)

  const coordinates = RA.map(v=>curve.map(u=>rotSlide(u,v)))  
  console.log("coordinates",coordinates)
 
  return coordinates 
}


const cutLoftByPlaneAndFillet = (sections,planes,fillet,config) => {
  
}
const divideZ = (mainZ, bottomXYZ, topXYZ, Ns) => {
  const min = bottomXYZ.length !==0 ? bottomXYZ[bottomXYZ.length-1][2] : mainZ[0]
  const max = topXYZ.length !==0 ? topXYZ[topXYZ.length-1][2] : mainZ[mainZ.length-1]
  const list = divideMinMax(min, max, Ns)
  return list
}

const makeLoftObj = sections => {
  const ribs = transpose(sections)
  
  const ribsX = ribs.map(v=>v.map(u=>u[0])) 
  const ribsY = ribs.map(v=>v.map(u=>u[1])) 
  const ribsZ = ribs.map(v=>v.map(u=>u[2])) 
  const ribsSplineZX = ribsZ.map((v,i)=>sci.interpolate.cubicspline(v,ribsX[i]))
  const ribsSplineZY = ribsZ.map((v,i)=>sci.interpolate.cubicspline(v,ribsY[i]))
 
  const ribsC = ribs.map(v=>v.map(u=>cartesianToCylindrical(u)))
  
  const ribsCX = ribsC.map(v=>v.map(u=>u[0]))
  const ribsCRT = ribsC.map(v=>v.map(u=>u[1])) 
  const ribsCR = ribsC.map(v=>v.map(u=>u[2])) 
  const ribsCSplineRX = ribsCR.map((v,i)=>sci.interpolate.cubicspline(v,ribsCX[i]))
  const ribsCSplineRRT = ribsCR.map((v,i)=>sci.interpolate.cubicspline(v,ribsCRT[i]))
  
  const loftObj = {
    sections: sections,  
    ribs: ribs,  
    ribsX: ribsX,
    ribsY: ribsY,
    ribsZ: ribsZ,
    ribsSplineZX: ribsSplineZX,
    ribsSplineZY: ribsSplineZY,
    ribsC: ribsC,
    ribsCX: ribsCX,
    ribsCRT: ribsCRT,
    ribsCR: ribsCR,
    ribsCSplineRX: ribsCSplineRX,
    ribsCSplineRRT: ribsCSplineRRT,
  } 
  return loftObj
}

const getCrossPointsOfLoftAndCone = (loftObj, path) => {
  const {ribsCR, ribsCSplineRX,ribsCSplineRRT} = loftObj
  const rIni =  ribsCR.map(v=>v[0])
  const crossPointsR = ribsCSplineRX.map((v,i)=>getCrossPointsOfSplineAndCone(v,  path, rIni[i], 30, 1E-5))
  const crossPointsXRTR = crossPointsR.map((v,i)=>[ribsCSplineRX[i].f(v), ribsCSplineRRT[i].f(v), v]) 
  console.log("crossPoints", crossPointsXRTR) 
  
  const crossPointsXYZ =  crossPointsXRTR.map(v=>cylindricalToCartesian(v))
  return crossPointsXYZ
}

const getFilletPolylines = (loftObj, path, fillet, filletDivisions, upside) => {
  const {sections,ribsCR, ribsZ,ribsSplineZX,ribsSplineZY} = loftObj
  
  const offsetSections = getOffsetSurface(sections, fillet) 
  const offsetRibs = transpose(offsetSections) 
  const offsetRibsZ = offsetRibs.map(v=>v.map(u=>u[2]))
  
  const convertZfunc = ribsZ.map((v,i)=>sci.interpolate.cubicspline(offsetRibsZ[i],v))
  
  const offsetRibsC = offsetRibs.map(v=>v.map(u=>cartesianToCylindrical(u)))
  const offsetRibsCX = offsetRibsC.map(v=>v.map(u=>u[0]))
  const offsetRibsCRT = offsetRibsC.map(v=>v.map(u=>u[1])) 
  const offsetRibsCR = offsetRibsC.map(v=>v.map(u=>u[2])) 
  const offsetRibsCSplineRX = offsetRibsCR.map((v,i)=>sci.interpolate.cubicspline(v,offsetRibsCX[i]))
  const offsetRibsCSplineRRT = offsetRibsCR.map((v,i)=>sci.interpolate.cubicspline(v,offsetRibsCRT[i]))


  const rIni =  ribsCR.map(v=>v[0])
  const offset_Path = upside ? offsetPath(path, fillet) : offsetPath(path, -fillet)
  const filletCenterR =offsetRibsCSplineRX.map((v,i)=>getCrossPointsOfSplineAndCone(v, offset_Path, rIni[i], 30,1E-5))
  const filletCenterXRTR = filletCenterR.map((v,i)=>[offsetRibsCSplineRX[i].f(v), offsetRibsCSplineRRT[i].f(v), v])
  const filletCenterXYZ = filletCenterXRTR.map(v=>cylindricalToCartesian(v))
  
  console.log("filletCenterXYZ" ,filletCenterXYZ )
 
 
  const contactRibsZTmp = filletCenterXYZ.map((v,i)=>convertZfunc[i].f(v[2]))  
  console.log("contactRibsZTmp",contactRibsZTmp)
  
  //const contactXYZ = filletCenterXYZ.map(
  //  (v,i)=>getPerpendicularHootFromPoint(ribSplineZX[i],ribSplineZY[i],v,contactRibsZTmp[i],1E-5)
  //)
  const contactXYZ = contactRibsZTmp.map((v,i)=>[ribsSplineZX[i].f(v),ribsSplineZY[i].f(v), v])
  console.log("contactXYZ" ,contactXYZ )
  
  const footXYZ = filletCenterXYZ.map(v=>getPerpendicularFooForCone(path, v))
  console.log("footXYZ", footXYZ)
  
  const filletPolylines = filletCenterXYZ.map((v,i)=>getFilletPolyline(v,contactXYZ[i],footXYZ[i], fillet, filletDivisions))
  console.log("filletPoylines", filletPolylines)
  if(!upside){
    filletPolylines.forEach(v=>v.reverse())
  }
  
  return filletPolylines  
}


const cutLoftByConeAndFillet = (sections, paths, fillet, config) => {
  const bottomPath = paths?.bottom
  const topPath = paths?.top
  const bottomFillet = fillet?.bottom
  const topFillet = fillet?.top
  const bottomFilletDivisions = config?.bottomFilletDivisions || 16
  const topFilletDivisions = config?.topFilletDivisions ||16
  
  const bottomCutFlag = bottomPath != undefined
  const topCutFlag = topPath != undefined 
  const bottomFilletFlag = bottomFillet !=undefined
  const topFilletFlag = topFillet !=undefined
  
  if(bottomFilletFlag===true && bottomCutFlag ===false){
    throw new Error("bottom path has to be defined for bottom fillet.")
  }
  if(topFilletFlag===true && topCutFlag ===false){
    throw new Error("top path has to be defined for top fillet.")
  } 

  const loftObj = makeLoftObj(sections) 
  
  const obj = {} 
  if(bottomCutFlag){
    const path = bottomPath
    const crossPointsXYZ = getCrossPointsOfLoftAndCone(loftObj, path)
    console.log("crossPointsXYZ",crossPointsXYZ)
    obj.bottomXYZ = transpose([crossPointsXYZ])
  }
  else{
    obj.bottomtXYZ =ribs.map(v=>[])
  }
  
  if(topCutFlag){
    const path = topPath
    const crossPointsXYZ = getCrossPointsOfLoftAndCone(loftObj, path)
    console.log("crossPointsXYZ",crossPointsXYZ)
    obj.topXYZ = transpose([crossPointsXYZ])
  } 
  else{
    obj.topXYZ = ribs.map(v=>[])
  }
  
   
  if(bottomFilletFlag){
    const path = bottomPath
    const fillet = bottomFillet
    const filletDivisions = bottomFilletDivisions
 
    const filletPolylines = getFilletPolylines(loftObj, path, fillet, filletDivisions, true)
    obj.bottomXYZ = filletPolylines 
  }
    
  if(topFilletFlag){
    const path = topPath
    const fillet = topFillet
    const filletDivisions = topFilletDivisions
 
    const filletPolylines = getFilletPolylines(loftObj, path, fillet, filletDivisions, false)
    
   
    obj.topXYZ = filletPolylines
  }

  const {ribsZ, ribsSplineZX, ribsSplineZY} = loftObj
  console.log("obj",obj) 
  const Ns = sections.length
  const ribsZCut = ribsZ.map((v,i)=>divideZ(v, obj.bottomXYZ[i], obj.topXYZ[i], Ns))
  const newRibs = ribsZCut.map((v,i)=>v.map(u=>[ribsSplineZX[i].f(u),ribsSplineZY[i].f(u), u]))
  const mergedRibs = newRibs.map((v,i)=>
    (obj.bottomXYZ[i].length !== 0 && obj.topXYZ[i].length !== 0) ? [].concat(obj.bottomXYZ[i], v.slice(1, -1), obj.topXYZ[i]) :
    (obj.bottomXYZ[i].length === 0 && obj.topXYZ[i].length !== 0) ? [].concat(v.slice(0, -1), obj.topXYZ[i]) :
    (obj.bottomXYZ[i].length !== 0 && obj.topXYZ[i].length === 0) ? [].concat(obj.bottomXYZ[i], v.slice(1)) :
    v
  )
  
  const newSections = transpose(mergedRibs) 
  
  return newSections
}

const main = async () => {
  const width = 800
  const height = 800
  
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45,width/height, 0.1, 3000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(new THREE.Color("rgb(0,0,0)"));
  renderer.setSize(width, height);

  const controls =  new THREE.OrbitControls( camera );
  const axes = new THREE.AxesHelper(100);
  scene.add(axes);
  const geometry = new THREE.Geometry();
  

  const sections = makeSections(f1,f2,RA,{N:31,M:16,L:51})
 
  
//filet  
  const paths = {
    bottom:[ [-20,315], [20, 305]],
    top:  [[-20, 390], [20,380]],
  }
  const fillets ={
    bottom: 10,
    top: 5,
  }  
  const config = {
    bottomfilletDivisions : 17,
    topFilletDivisions : 17,
  }
  
  const sections2 = cutLoftByConeAndFillet(sections, paths, fillets, config) 
  sections2.forEach(v=>{
    const line = getThreePolylineObj(v,"red",true)   
    scene.add(line)
  })
  
  const sections2T = transpose(sections2) 
  sections2T.forEach(v=>{
    const line = getThreePolylineObj(v,"red",false)   
    scene.add(line)
  }) 
  
  
  camera.position.x = 100;
  camera.position.y = 100;
  camera.position.z = 100; 
  
  const animate =() =>{
    requestAnimationFrame( animate );
    renderer.render( scene, camera );
    controls.update();
  }

  document.getElementById("draw").appendChild(renderer.domElement);
  
//renderer.render(scene, camera)

  animate();
  
  exportText = JSON.stringify(sections2, null, "  ")
  exportFileName = "coordinates.json"
}
main()

const test = () => {
  const ori = [9.744665027670174, -2.2453292628257954, 0] 
  const ori2 = [2.425356250363322, 0.952097951227001, -9.654592510825765]
  //const ori = [2,0,0]
  //const ori2 = normVec([1,1,1])
  
  const phi = getAngle(ori, ori2) 
  const phiDeg = phi * 180/Math.PI
  console.log("phiDeg",phiDeg)
  const N = 9
  const ax = normVec(vectorProduct(ori, ori2))
  console.log(ax)
  
  const q = makeQuaternion(ax, phi)
  const Q = [...ori, 0] 
  const Q2 = mulQQlist([q,Q,invQuaternion(q)])
  console.log(Q2, absVec(Q2))
//  const n = [0,1,0]
//  const phi = Math.PI/2
//  const q = makeQuaternion(n,phi)
//  const invq = invQuaternion(q)
//  const p = makeQuaternion(ori,0)
//  const r = mulQQlist([q,p,invQuaternion(q)])
//  //const r2 = mulQQ(r,invq)
//  console.log(r)

  const obj = {a:1} 
  console.log(obj.b !=undefined)
  const list = []
  console.log(list[5])
  console.log([].concat([],[[11,3]],[]))
}

//test()